Something of a minimalist start to documenting the internal structures of
XFamily.

the displaytree structure

this is a linked graph containing two sorts of object, indidisplay
and famdisplay structures. These structures contain the pointers
which link the graph together into the family tree you see on screen.

each displaytree (there is one for each open view onto the GEDCOM) is
rooted at an indidisplay whose pointer is displaytree::treetop

Each indidisplay contains a pointer to its associated GEDCOM object (always
an INDI), to an optional famdisplay and an optional next indidisplay (which
would be the display for a younger sibling)

Each famdisplay similarly contains a pointer to its GEDCOM object (always
a FAM), to an optional indidisplay for the spouse of the family, an optional
pointer to the next famdisplay (for INDIs with more than one marriage) and
an optional pointer to the indidisplay for the eldest issue.

Each of these objects also contains positional information and stuff to build
the visible representation of the tree.

All the code for this lives in display.h and display.cxx

----------------------------------------------------------------------------------

an indidisplay is the structure for the name of an individual, and the dates,
and includes a pointer back to the INDI object, and the position and size
on the canvas.

a famdisplay is the structure which contains the location of an "=" on the
canvas, and the date, if known/shown. It has a pointer to the FAM object
and a pointer to the indidisplay of the person below the =, if there is one.

------------------------------------------------------------------------------

The key to understanding this lot is to see what happens when we set a new current
person for a particular view

[ in conjunction with this next bit of documentation, you should also consider
 the file Eliminate-treeinstance-geteventobject as we have reasons to change
 how this stuff works... ]

the popup_cb callback on the mainUI checks for view->main->whoisat to see if an
indidisplay or famdisplay has been clicked on. If it's an indidisplay and a left
button click, we'll call view->setcurrent( clicked ) where clicked is the pointer
to the relevant INDI object (NOT the indidisplay - we've already indirected to
the GEDCOM-object).

We must also have a way to set the current person from the find people main menu
item (and "completions" chooser). In either case, the userdata passed to the
callback is the pointer to the particular view, so we have enough context to set
the current person on the correct view.

And finally, when a file is first loaded we will set view->setcurrent( ) for
the current person saved in the file (or one per view, opening a view for each
of those objects [ at 2017-09-22 we only open one view, I believe, on the
first person noted ]). First we try one or more 0 NOTE view objects (with
noted_view()) and only if this fails do we fall back on a single 0 NOTE person
object (with noted_person())

So: view->setcurrent( GEDCOM-object* ) is a call on mainUI::setcurrent in gui.cxx

the first thing we do is test if person==newperson, from which we deduce that
person is a pointer to the INDI object of the current person (and a member of
the mainUI class, not the treedisplay class). We don't need to do anything.

Next we set the window title. Easy. Unless newperson was NULL - then we
crash. As of v017, we don't seem to crash quite yet...

this->settop() works out, from the current person, who the top of the tree must
be - 1st choice, current person's father, 2nd choice, current person's mother,
final choice, current person. So that sets mainUI::topind

this->newdisplay()
first, if a display already exists for this view, delete it
display = new displaytree( topind, current ) calls the constructor
 which sets displaytree::treecurrent to point at the current person
 creates the first indidisplay, at displaytree::treetop
display->buildtree() builds the tree structure which generates lots of
indidisplay and famdisplay objects, linking them with the appropriate pointers.
During this process, when we find that the indidisplay we are building is
the one for the current person, we set displaytree::indicurrent to it
This works out the size of each name and so on, but not where it is.
display->calctree() is the cunning algorithm that works out where everything
 goes. There is scope for improvement here.


