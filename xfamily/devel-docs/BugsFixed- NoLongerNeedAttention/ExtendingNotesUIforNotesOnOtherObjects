done all this:

We should be able to add a NOTE to any object. Currently we can only do so to a
top level INDI or FAM object. notesUI has been written to deal with TEXT objects too,
but is not yet called upon to do so anywhere.

We find the object to which we are attaching notes by virtue of being passed a pointer
to the treeinstance in which the object is defined, and then relying on the menu
pop-up having called a setevent for the relevant object. This is a rather roundabout
way of getting to the object - it would seem more sensible to passs the opennotes_cb
callback a pointer to the GEDCOM_object whose NOTE subobject we wish to edit. The
reason we didn't do this is that we want to be able to label the edit window title
bar with the name of the tree in which the object lies, and we don't have a way
back to this from the GEDCOM_object.

In order to generalise this UI, it is going to be a lot more sensible to provide a
way to get back to that information.     I think.... Because we are going to have
a variety of ways to open a notesUI which don't rely on a menu pop-up event, and,
in particular, we may be raised by something which doesn't know the treeinstance,
or from whose treeinstance it may be very hard to find the GEDCOM_object we are
being raised for. It is much more general and cleaner if we always have a way from
a GEDCOM_object back up the structure to any enclosing object, including, ultimately,
the treeinstance.

TO do that we need to add to the GEDCOM_object class - we don't currently have a
pointer to the parent object - eventually we are going to need one for freeing
objects, I'm sure, so the sooner we add one the less headache... Following such
parent pointers up, you will eventually reach an object with the tag root_tag.
Its parent pointer cannot point to the treeinstance if it is a GEDCOM_object*,
because you'd need a treeinstance*. Not sure of a clean way to do that, but
it looks as though you need to add a GEDCOM_object constructor which takes a
treeinstance* as parameter, which would only be used for creating the root object,
and which would cast the treeinstance* to a GEDCOM_object* and save it in the
parent pointer. The GEDCOM_object::parent() method would then check that it was
being called on a non-root object before returning its GEDCOM_object*. For the
root object it would return NULL. There would then be another method to get
the tree of a GEDCOM_object. If called on a root object, it would cast the parent
back to treeinstance* and return it. For any other object it would repeatedly
call parent() until it got a null, then check that the last object it had reached
was the root object, then do the cast and return. Getting to the treeinstance
would always be pretty quick, since the typical tag nesting depths we see only
go up to about 5.

It looks as if the method to return the treeinstance must be public, but the
parent() method can be private

Whilst we are on this topic we need to be sure that we cannot raise a second edit
notes UI on the same object. This seems to be OK, at the moment, but we need to watch
that we don't provide a loophole into this trap. It is not the constructor which checks...
Ah, this is quite well written, in fact, we have a noteslist class which is just a
linked list of notesUI instances, so when we call NotesUIs->open(...) we check through
the list to see if such a notes window is already open. Great so we won't get the loophole.
But there is a BUG ! We can raise a notesUI on an object with either a NOTE tag or a
TEXT tag. noteslist->open() takes the tag as a parameter, but doesn't check it, so
if we try to open a window to edit a TEXT item on an object for which we are already
editing a NOTE object, we won't get the new window we expected, but the NOTE editor will
be raised and get the focus. OOPS !  OK, seem to have fixed that fairly easily, 2003-12-22


OK, you might care to note that notesUI has been written to edit not just NOTE
objects, but TEXT ones too, so the constructor takes a treeinstance, a GEDCOM_object
and a GEDCOM_tag