Immediate steps:

Clean out redundant code from fix0005 and fix0006 once they have been tested
for long enough to be happy.

1) make sure saving file works (not part of fix0004, but needed to ensure we
can test that fix0004 is creating the right structures). We need to be able
to save to a new file (by default at the moment we save to /var/test.ged -
a fixed filename guaranteed not to overwrite our original data), which is
good for testing and saves us writing a save file dialogue straight away
(although that *ought* to be straightforward...).

File saving works, but it's still to /var/test.ged Note that in order to make
diffs easier to read, we changed the max length of text object lines to stop
it splitting our overlength lines (they're not overlength by the GEDCOM spec.
just by our own preferred length)

OK, we fixed loading/saving state in 0 NOTE Person and View objects.
We don't save GEDCOM from the ephemlist, but we *do* save GEDCOM with
references into the ephemlist, which, not being in the GEDCOM we saved,
means we can save broken GEDCOM. One of the ideas of having flags on
GEDCOM_object is that we can mark an object as being ephemeral - not
just an INDO or FAM and all it's subobjects, but also subobjects (of
real objects) which carry references to ephemera. Then we simply check
flag during output and simply don't write out those objects. I believe
that is safe, because if an object would be invalid (say a FAM with zero
or one references), it would itself be ephemeral.

2) garbage collect ephemerals - this is critical: for an INDI who had
no parents when we started editing, we have added a FAMC object pointing
to an ephemeral FAM - leaving that in the GEDCOM would be terminal !
Having objects flagged as ephemeral ensures they don't get saved if they
exist legitimately when user does a save file (so we need to do this!).

3) move info from ephemerals into permanent structure (then garbage
collecting anything left). Unflag their ephemerality...

4) Check for side effects on other famUI and indiUI dboxes.

2,3,4 at this stage are just for changes we make in indiUIs.

Next step is to go through the same process for famUIs.


Once we have the technology to create new individuals, we should,
before making the system any more complex, solve the issue of
starting up with an empty tree. Currently this causes a crash...
We seem to be able to have an empty display with no current person,
but any time you click on the display, we segfault.

We need basically to be able to cope with the situation where
there is no current person. This doesn't necessarily mean an
empty tree - we may load a tree with an invalid current person
(logic says that we should pop up a find person dbox, but in the
meantime we still need to cope with a blank display). Another way
we lose the current person is if we delete the current person from
the tree. There's a logical way to select a new current person if
we had a tree displayed, but if we delete an isolated person, we
again end with an empty display.

We note that if we load a tree and fail to set a current person,
we do put up an empty display without crashing. But as soon as we
click anywhere, we get a segfault. That suggests that debugging
when/where the crash occurs will point to a way forward.

On failure to set a current person we probably ought to tell the
user how big the tree he just loaded is (pop up stats box), then
alert him that we couldn't set the current person, and pop up a
GoTo dbox.

But even with an empty window (or null tree), he should be able
to click to pop up a menu and do "create new person". Currently
a right click in empty whitespace gets no context menu on which
"create new person" could be added.

The canvas is a button, so we should be receiving a callback for
that click, then looking at the pixel location to determine if
user clicked on a person or family. If not we do nothing, but
*should* open a context menu appropriate to a whitespace click.

====================================================================

testing work:

At some stage we are going to start modifying the tree, which will
involve destroying objects and freeing up memory. Although the
program visibly works, we haven't done any testing to show that
destructors are actually being called, so we have no real confidence
that the code isn't riddled with potentially massive memory leaks.

Already we blithely create a new display structure every time we
change current person, so we should be checking that everything
we created gets destroyed. Suggest a bit of conditional compilation
in fixes.h. #define debugging is our switch for dynamic instrumentation
and I don't want destructor testing turned on every time I set up to
debug some new bit of code, so suggest we have a separate variable,
like #define destructorlogs.

This will also be useful as I do need to write code to close one
display without exiting the program. Here I'll want not only to
see that stuff *is* being destroyed, but also what stuff it is,
since we want to be sure we're not destroying stuff in the wrong
display structure...

NOTES: we don't have a destructor for a GEDCOM_tag - we should never
be destroying these. we don't seem to have a destructor for mainUI,
infoUI (which is probably OK, we only ever make one and its static),
statsUI (this is probably OK, we probably only need one, and refill
it's values whenever shown. Actually, there's one for each
treeinstance so we would want to destroy one if we stopped editing
a particular tree - we do have a treeinstance destructor and it calls
delete statsbox, so a statsUI destructor would be called - but does
it actually need to do any work ?), findUI (this is transient, but we
specifically only ever want one, so we've decided that it is static),
prefUI - fine, that's static and global.

completionsUI - this is definitely iffy. All reasonable user interface
logic says we should never have more than one of these (otherwise we
have to find some way to identify the buggers with some link to the
field they were raised on), but we will be creating several ways of
looking for things that will raise one - even if we only have one and
close all others, we probably do need some identifier title... However,
yes, we probably don't need a destructor at the moment.


