Denis Howes' heap code for !Family:

Heap is of arbitrary size (word-aligned and sized)

Heap%!0 = HeapSize%-8
Heap%!(HeapSize%-4) =0   last word set to zero

Free% = Heap%
HeapFree% = HeapSize%

The first word of any heap block has

 bit 0      set => used, clear => free
 bits 1-31  block size in bytes (excluding the first word)

so, if B% points to a block, B%+4+(!B% AND NOT 1) points to the next

Free% might point to the first free block, but if a block has just been
allocated which was an exact fit, it points to the block following that one,
which will never, in fact, be free. This means that the Alloc routine always
needs to check whether the block pointed to by Free% is actually free, and
follow pointers until it finds one that is. The following of the chain will
always need to be done at some stage, but if it was done after the exact fit
block was allocated, it would save doing the check *every* time we allocated
a block.

In fact, Free% might *not* point to the first free block. If we fail to
allocate a block because it was just 4 bytes too big, then Free% ends up
pointing at the block following the one we allocate, so that free block
becomes inaccessible. A bug ! That block will only become accessible once
again if we later free a block at a lower address, in which case it will
later be found by jumping through the list from that lower free pointer.
This is all a bit hit and miss...

Problems:

there is no free chain - finding a free heap block involves searching the
entire chain of blocks, free or used, starting from the Free pointer,
which could well point to a freed block very near the beginning of the
heap. This is very inefficient.

the free pointer is not guaranteed to point to a free block, nor can all
free blocks be found by starting from it

amalgamation of free blocks is not done until a block is being searched for.
This may be a time saving measure, but would need fixing before the above two
problems are properly solvable.

Plus points:

We can, in fact, extend the heap by adding more WimpSlot any time we like.
The end marker is effectively the first word of a zero-length block. Since
we take pains to ensure that those don't exist anywhere, the end marker is
instantly identifiable. To extend the heap, you merely have to
traverse the chain until you reach the last block (which should be free,
and can be identified because its length will point to the last word in
the heap. Add the amount by which the heap has been extended to this length
and set the last word to zero). In fact a quicker way to do this, given the
current scheme, is simply to change the last word of the old heap to hold the
length-4 of the heap extension we added, and zero the last word. The free
block at the end of the old heap will be amalgamated with the new free block
during the normal allocation routine.

We use 32-bit pointers into the heap, so any block may be up to 4Gb long.
Hardware limits kick in way before this, of course :-)

Allocation strategy:

In an ideal world, heap allocation strategies are quite a bit more
intelligent than this. First, search overhead is reduced by keeping a
proper list of free blocks, rather than just a list of all blocks.
Second, when allocating, try first to find a block of the exact size,
which helps to reduce fragmentation. Third, amalgamate blocks when
freeing - this is harder, unless used blocks have a back pointer as
well as a forward one. This is not as hard as it sounds, since if free
blocks are amalgamated, we can always find the next used block which
follows immediately. Its "previous" pointer is copied to that of the new
block used, then updated to point to that new block.

Memory overhead is increased in this scheme, since each block needs
two pointers:

For a free block:  length, pointer to next free block
For a used block:  length, pointer to previous used block

In !Family, each of our heap blocks in less than 80 bytes (and many are
much less [the average line length in Kin16e is 23.2 chars, of which
"0 Atag" are never put on the heap (but lines which comprise just a tag
are GEDCOM objects with no string associated).

So the string component of a GEDCOM line is probably mid twenties, and
a GEDCOM object is 20 bytes, a display structure a bit smaller. Lets be
optimistic and say the average sized heap item is 28 bytes long. So it
needs 32 heap bytes now and will need 36 bytes in the new scheme. A 12½%
increase in memory usage. That's quite a hit - it will need to show a
significant speed up to be worth it on older machines with not a lot
of memory to play with.

A strategy to cope with that is to code assembly routines for both heap
structures, and load a "low memory" or "high speed" method by user choice.
That's more work :-(

============================================================================

When we fake a top object we do a TopChil%= FNObject(ChilTg%,FNFore(Person%))

The FNObject does a FNAlloc(ObSize%) and creates an object with null
pointers except for the tag (->"CHIL") and value (=FNFore(Person%))

then we do a DStruct, which creates a DStruct and a disp object which
is set up as the first subobject of the object we were called on (which
was the above CHIL object). The DStruct is the value of the disp object.

So to destroy this stuff (before making another one), we need to free
the DStruct, the Disp object and the fake Chil object.

So how come FreeOb(TopChil%) doesn't do that ?

Well, firstly, FreeOb doesn't destroy any subobjects, so it won't get
rid of the Disp object or the DStruct. We would want to do DelObj instead,
which would call DelObj on the Disp object, which would call FreeOb on
it, which would free the DStruct and then the Disp. On return, it would
then call FreeOb on TopChil%, but this is what seems to break the code...

TopChil%!ObVal% = FNFore(Person%) and FreeOb does a Free on that if it is
a real pointer (rather than a cross-reference). That doesn't seem definitely
bad news, as TopChil% is a CHIL object, so that the value *should* be a
cross-reference, but I suspect in fact that it isn't - no, its definitely
a raw pointer to an INDI object.

So we cannot safely call DelObj on TopChil - we need to call FreeOb on the
first (and only) subobject of TopChil, then just call Free on TopChil itself.
